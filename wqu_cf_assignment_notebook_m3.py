# -*- coding: utf-8 -*-
"""WQU_CF_Assignment_Notebook_M3 v4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NTpBk334l915KwPbczd28Jm-s9X7-QSY
"""

#!pip install tqdm

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt 
from scipy.stats import norm
from tqdm import tqdm
import functools 

# %matplotlib inline

def share_path(S_0, r, sigma, Z, dT):
    return S_0 * np.exp(np.cumsum((r - sigma**2/2) * dT + sigma * np.sqrt(dT) * Z))

def european_call_payoff(S_T, K, r, T):
    """S_T is the price of the underlying at expiry.
    K is the strike price
    r is the risk free rate
    T is the time period till maturity"""
    return np.exp(-T*r) * np.maximum(0, S_T - K) #payoff for call option

def euro_uao_call(barrier, paths, K, r, T):
    """barrier is the barrier level,
    paths is a list of share price paths,
    K is the strike price
    r is the risk free rate
    T is the time period of each share price path"""
    prices = []
    for path in paths:
            if np.max(path) > barrier: # knocked out
                    prices.append(0)
            else:
                    prices.append(european_call_payoff(path[-1], K, r, T)) 
    return np.mean(prices)

T = 1                   #expiry time of option
L = 150                 #barrier limit
S_0 = 100               #starting share value
K = 100                 #strike price
V_0 = 100               #starting firm value
r = 0.08                #interest rate
sigma_s = 0.30          #share volatility
sigma_v = 0.25          #firm value volatility
debt = 175              #firm debt
correlation = 0.2       #correlation between share and firm
recovery_rate = 0.25    #firm recovery rate
frequency = 12          #monthly simulations for a year

corr_matrix = np.array([[1, correlation], [correlation, 1]])

plt.rcParams["figure.figsize"] = (30,20)
fig, ax = plt.subplots(13,4, sharex=True, sharey=True)
plt.xticks (range (1,13))
plt.ylabel ('USD')

# 1. Simulate paths for the underlying share and for the counterpartyâ€™s firm value using sample sizes of 1000, 2000, ..., 50000. 
# Do monthly simulations for the lifetime of the option.
#2. Determine Monte Carlo estimates of both the default-free value of the option and the Credit Valuation Adjustment (CVA).
#3. Calculate the Monte Carlo estimates for the price of the option incorporating counterparty risk, given by the default-free price less the CVA.

call_val_list = []
cva_list = []
adjusted_call_list = []

for sampleSize in tqdm(range(1000, 51000, 1000)):
    share_path_list = []
    firm_value_list = []
    
    #for each sample size, sum up all price path for each simulation so that the mean can be calculated later
    for i in range(0, sampleSize):
        norm_matrix = norm.rvs(size=np.array([2, frequency]))
        corr_norm_matrix = np.matmul(np.linalg.cholesky(corr_matrix), norm_matrix)
        share_price_path = share_path(S_0, r, sigma_s, corr_norm_matrix[0,], T/frequency)
        firm_value_path = share_path(V_0, r, sigma_v, corr_norm_matrix[1,], T/frequency)
        share_path_list.append(share_price_path)
        firm_value_list.append(firm_value_path)

    #get the mean path for the sum of all the simulations
    share_path_mean = list(map(lambda summed: summed/sampleSize,  functools.reduce(lambda a,b: [x + y for x, y in zip(a, b)], share_path_list)))
    firm_value_mean = list(map(lambda summed: summed/sampleSize,  functools.reduce(lambda a,b: [x + y for x, y in zip(a, b)], firm_value_list)))

    """Note that the code above is the same as question 1"""

    ################################################
    #######     terminal value of option   #########
    ################################################
    #print(share_path_list)
    call_val = euro_uao_call(L, share_path_list, K, r, T) # obtain the Up-and-out European call option value using the defined function euro_uao_call
    # Extract the terminal firm values
    term_firm_values = list(map(lambda x: x[-1], firm_value_list))
    
    # Note: the explanation of the functions are defined above under the "Define functions" section

    ################################################
    #######               CVA              #########
    ################################################

    # To calculate the amount lost, we apply the formula [np.exp(-T/frequency*r) * (1-recovery_rate)*(term_firm_val < debt) * call_val]
    # for each simulated terminal firm value in the monte carlo simulation. 
    amount_lost = [np.exp(-T/frequency*r) * (1-recovery_rate)*(term_firm_val < debt) * call_val for term_firm_val in term_firm_values] # calculate the amount lost
    cva = np.mean(amount_lost)
    adjusted_opt_val = call_val - cva
    
    call_val_list.append(call_val)
    cva_list.append(cva)
    adjusted_call_list.append(adjusted_opt_val)
    
    print('-' * 20)
    print("For sample Size: " + str(sampleSize))
    print("The European up-and-out call option price is {}.".format(call_val))
    print("The mean Credit Valuation Adjustment is {}.".format(cva))
    print("The price of the option less the counter party risk is {}.".format(adjusted_opt_val))
    print('-' * 20)
        
xi = [i for i in range(1000, 51000, 1000)]   
    
plt.title ('Option Value, CVA vs Sample Size ')
plt.plot (xi, call_val_list, label = 'Default Option Price')
plt.plot (xi, cva_list, label = 'CVA')
plt.plot (xi, adjusted_call_list, label = 'Adjusted Option Price')
plt.xlabel ('Sample Size')    
plt.legend()
plt.show()