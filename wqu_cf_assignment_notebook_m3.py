# -*- coding: utf-8 -*-
"""WQU_CF_Assignment_Notebook_M3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14XHXXaPMkQV0jw4l8E5IeGNz57DFrJc5
"""

import numpy as np
import matplotlib.pyplot as plt 
from scipy.stats import norm

def share_path(S_0, r, sigma, Z, dT):
    return S_0 * np.exp(np.cumsum((r - sigma**2/2) * dT + sigma * np.sqrt(dT) * Z))

def european_call_payoff(S_T, K, r, T):
    """S_T is the price of the underlying at expiry.
    K is the strike price
    r is the risk free rate
    T is the time period till maturity"""
    return np.exp(-T*r) * np.maximum(0, S_T - K) #payoff for call option

def euro_uao_call(barrier, paths, K, r, T):
    """barrier is the barrier level,
    paths is a list of share price paths,
    K is the strike price
    r is the risk free rate
    T is the time period of each share price path"""
    prices = []
    for path in paths:
            if np.max(path) > barrier: # knocked out
                    prices.append(0)
            else:
                    prices.append(european_call_payoff(path, K, r, T)) 
    return np.mean(prices)
    
def sumUpPricePath(path, path_total):
    return [x + y for x, y in zip(path_total, path)]

T = 1
L = 150
S_0 = 100
K = 100
V_0 = 100
r = 0.08
sigma_s = 0.30
sigma_v = 0.25
debt = 175
corr = 0.2
recovery_rate = 0.25
frequency = 12
correlation = 0.2

corr_matrix = np.array([[1, correlation], [correlation, 1]])

# 1. Simulate paths for the underlying share and for the counterpartyâ€™s firm value using sample sizes of 1000, 2000, ..., 50000. 
# Do monthly simulations for the lifetime of the option.

for sampleSize in range(1000, 51000, 1000):
    share_path_total = [0] * frequency
    firm_value_total = [0] * frequency
    
    #for each sample size, sum up all price path for each simulation so that the mean can be calculated later
    for i in range(0, sampleSize):
        norm_matrix = norm.rvs(size=np.array([2, frequency]))
        corr_norm_matrix = np.matmul(np.linalg.cholesky(corr_matrix), norm_matrix)
        share_price_path = share_path(S_0, r, sigma_s, corr_norm_matrix[0,], T/frequency)
        firm_value_path = share_path(V_0, r, sigma_v, corr_norm_matrix[1,], T/frequency)
        share_path_total = sumUpPricePath(share_price_path, share_path_total)
        firm_value_total = sumUpPricePath(firm_value_path, firm_value_total)
        
    #get the mean path for the sum of all the simulations
    share_path_mean = list(map(lambda totalShare: totalShare/sampleSize, share_path_total))
    firm_value_mean = list(map(lambda totalShare: totalShare/sampleSize, firm_value_total))
    print("Sample Size: " + str(sampleSize))
    print("Share price path is " + str(share_path_mean))
    print("Firm value path is " + str(firm_value_mean))
    print("\n")

#2. Determine Monte Carlo estimates of both the default-free value of the option and the Credit Valuation Adjustment (CVA).
#3. Calculate the Monte Carlo estimates for the price of the option incorporating counterparty risk, given by the default-free price less the CVA.

call_opt_val, cva_estimates, cva_std = [], [], []

for sampleSize in range(1000, 51000, 1000):
    share_path_total = [0] * frequency
    firm_value_total = [0] * frequency
    
    #for each sample size, sum up all price path for each simulation so that the mean can be calculated later
    for i in range(0, sampleSize):
        norm_matrix = norm.rvs(size=np.array([2, frequency]))
        corr_norm_matrix = np.matmul(np.linalg.cholesky(corr_matrix), norm_matrix)
        share_price_path = share_path(S_0, r, sigma_s, corr_norm_matrix[0,], T/frequency)
        firm_value_path = share_path(V_0, r, sigma_v, corr_norm_matrix[1,], T/frequency)
        share_path_total = sumUpPricePath(share_price_path, share_path_total)
        firm_value_total = sumUpPricePath(firm_value_path, firm_value_total)

    #get the mean path for the sum of all the simulations
    share_path_mean = list(map(lambda totalShare: totalShare/sampleSize, share_path_total))
    firm_value_mean = list(map(lambda totalShare: totalShare/sampleSize, firm_value_total))

    ################################################
    #######     terminal value of option   #########
    ################################################

    call_val = euro_uao_call(L, share_path_mean, K, r, T/frequency)
    call_opt_val.append(call_val)

    ################################################
    #######               CVA              #########
    ################################################

    amount_lost = [np.exp(-T/frequency*r) * (1-recovery_rate)*(term_firm_val < debt) * call_val for term_firm_val in firm_value_mean]
    cva_estimates.append(np.mean(amount_lost))
    cva_std.append(np.std(amount_lost) / np.sqrt(frequency))

#2a. Determine Monte Carlo estimates of the default-free value of the option 
#2b. Determine Monte Carlo estimates of the Credit Valuation Adjustment (CVA)
#3. Calculate the Monte Carlo estimates for counterparty risk

# print out the call_opt_val, cva_estimates and cva_std
call_opt_val = np.mean(call_opt_val)
cva_estimates = np.mean(cva_estimates)
cva_std = np.mean(cva_std)

counter_party_risk = call_opt_val - cva_estimates

print("The European up-and-out call option price is {}. \n".format(call_opt_val))
print("The Credit Valuation Adjustment  is {}. \n".format(cva_estimates))
print("The counter party risk is {}. \n".format(counter_party_risk))